---
description: Global workflow rules for planning, implementation, and code quality
alwaysApply: true
---

# Workflow Rules

## Issue-Driven Development (Source of Truth)
- GitHub Issues are the single source of truth for all planned work
- Every feature, enhancement, or task must have a corresponding GitHub issue before work begins
- Every bug must be filed as a GitHub issue before fixing
- Do NOT start coding without an issue to reference

## Starting Work
1. If working on a bug and no issue exists yet, create one first: `gh issue create --title "<title>" --label "bug" --body "<description>"`
2. Fetch the GitHub issue assigned to this task: `gh issue view <number>`
3. Confirm with user which issue we're working on
4. Assign yourself and add "in progress" label
5. Create a feature branch from up-to-date main: `git checkout main && git pull origin main && git checkout -b <branch>`
6. Implement the feature/fix per the issue description

## Planning Mode
- Output a concise plan before writing code
- Identify components/hooks affected and design patterns to use
- If less than 90% sure about intent, ask clarifying questions

## Implementation Flow
1. Structure First: Break tasks into small components/functions, show signatures only
2. Wait for Approval: Do not implement until reviewed
3. One by One: Implement each component individually, not large blocks

## Code Standards
- No comments in code (exception: complex "why" logic)
- No lazy coding: never use `// ... rest of code` placeholders
- Read target file's imports, types, and style before generating code
- Pin dependency versions exactly (no `^` or `~` ranges)
- Use `clsx` for all dynamic or conditional `className` values — never use template literals or string concatenation for classNames

## Route Files (TanStack Router)
- Default to **lazy routes** (`createLazyFileRoute` + `.lazy.tsx` suffix) for code-splitting
- Only use a non-lazy route (`createFileRoute` + plain `.tsx`) when the route needs eagerly-loaded features: `loader`, `beforeLoad`, search param validation, or other non-component route config
- The root route (`__root.tsx`) must always remain non-lazy

## OpenAPI Schema Alignment (Mandatory on Every Schema Change)
When the OpenAPI spec (`src/core/openapi.json`) changes, propagate those changes across ALL layers in order:

### Source of truth
`src/core/openapi.json` is the single contract. Everything else derives from it.

### Layer checklist (update in this order)
1. **Frontend Zod schemas** (`src/core/schemas/`) — mirror OpenAPI format constraints (`date-time` → `.datetime()`, `nullable` → `.nullish()`, `integer` → `.int()`, `maxLength` → `.max()`)
2. **Mock server request schemas** (`api/server.ts`) — create/patch Zod schemas must match the OpenAPI request body definitions (same required fields, same enums, same constraints)
3. **Mock server response behavior** (`api/server.ts`) — endpoints must return the correct HTTP status codes and response shapes defined in OpenAPI (e.g. DELETE returning `{ ok: true }` with 200, not 204)
4. **Mock data loader schemas** (`api/mock.ts`) — Zod schemas for loading persisted data must accept the same field shapes as the OpenAPI response schemas
5. **Mock data** (`api/mock-data.json`) — all values must satisfy the schemas above (valid UUIDs for `format: "uuid"`, RFC 3339 dates for `format: "date-time"`, `null` not `""` for nullable fields)
6. **Tests** — all mock/fixture data in test files must use valid formats matching the schemas

### Mock server endpoint alignment
For every path in `openapi.json`, verify the mock server (`api/server.ts`):
- **Exists** — every OpenAPI endpoint has a corresponding Fastify route
- **Method** — GET/POST/PATCH/DELETE matches
- **Request body validation** — Zod schema fields, required vs optional, enums, and constraints match the OpenAPI `requestBody` schema
- **Response status code** — matches the OpenAPI success response (e.g. 200, 201)
- **Response shape** — returned JSON matches the OpenAPI response schema (required fields present, correct types)
- **Path parameters** — validated the same way (e.g. `format: "uuid"`)

### Field-level checklist
- `format: "date-time"` → `z.string().datetime()` everywhere
- `nullable: true` + not required → `.nullish()` in frontend, `.nullable().optional()` in mock server
- `type: "integer"` → `.int()` everywhere
- `minLength` / `maxLength` → `.min()` / `.max()` everywhere
- `format: "uuid"` → IDs in mock data must be valid UUIDs
- Required fields in OpenAPI → NOT `.optional()` in Zod
- Fields NOT in an OpenAPI request body → NOT accepted by the mock server's Zod schema for that endpoint

## Debugging
- Stop on test/build failures - do not proceed
- Analyze root cause before fixing, don't randomly patch

## Git Branch Policy
- NEVER push directly to main
- Always create a feature branch and push to that branch
- Use PRs to merge into main

## Finalization
1. Run validation (build, lint, test)
2. Fix any failures automatically
3. Ask for user confirmation
4. Create commit on the feature branch and push to origin
5. Create PR linked to the issue
