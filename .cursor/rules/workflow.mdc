---
description: Global workflow rules for planning, implementation, and code quality
alwaysApply: true
---

# Workflow Rules

## Issue-Driven Development (Source of Truth)
- GitHub Issues are the single source of truth for all planned work
- Every feature, enhancement, or task must have a corresponding GitHub issue before work begins
- Every bug must be filed as a GitHub issue before fixing
- Do NOT start coding without an issue to reference

## Starting Work
1. If working on a bug and no issue exists yet, create one first: `gh issue create --title "<title>" --label "bug" --body "<description>"`
2. Fetch the GitHub issue assigned to this task: `gh issue view <number>`
3. Confirm with user which issue we're working on
4. Assign yourself and add "in progress" label
5. Create a feature branch from up-to-date main: `git checkout main && git pull origin main && git checkout -b <branch>`
6. Implement the feature/fix per the issue description

## Planning Mode
- Output a concise plan before writing code
- Identify components/hooks affected and design patterns to use
- If less than 90% sure about intent, ask clarifying questions

## Implementation Flow
1. Structure First: Break tasks into small components/functions, show signatures only
2. Wait for Approval: Do not implement until reviewed
3. One by One: Implement each component individually, not large blocks

## Code Standards
- No comments in code (exception: complex "why" logic)
- No lazy coding: never use `// ... rest of code` placeholders
- Read target file's imports, types, and style before generating code
- Pin dependency versions exactly (no `^` or `~` ranges)
- Use `clsx` for all dynamic or conditional `className` values — never use template literals or string concatenation for classNames

## Route Files (TanStack Router)
- Default to **lazy routes** (`createLazyFileRoute` + `.lazy.tsx` suffix) for code-splitting
- Only use a non-lazy route (`createFileRoute` + plain `.tsx`) when the route needs eagerly-loaded features: `loader`, `beforeLoad`, search param validation, or other non-component route config
- The root route (`__root.tsx`) must always remain non-lazy

## OpenAPI Schema Alignment (Mandatory on Every Schema Change)
When the OpenAPI spec (`src/core/openapi.json`) or any Zod schema changes, verify alignment across ALL four layers:
1. **OpenAPI spec** (`src/core/openapi.json`) — the contract
2. **Frontend Zod schemas** (`src/core/schemas/`) — must mirror OpenAPI format constraints (`date-time` → `.datetime()`, `nullable` → `.nullish()`, `integer` → `.int()`, `maxLength` → `.max()`)
3. **Mock server schemas** (`api/server.ts` request validation, `api/mock.ts` data loading) — must match the same constraints
4. **Mock data** (`api/mock-data.json`) — all values must satisfy the schemas above
5. **Tests** — all mock data in tests must use valid formats (e.g. RFC 3339 dates with `Z` suffix)

Checklist per schema field:
- `format: "date-time"` → `z.string().datetime()` everywhere (frontend, mock server, mock loader)
- `nullable: true` + not required → `.nullish()` in frontend, `.nullable().optional()` in mock server
- `type: "integer"` → `.int()` everywhere
- `minLength` / `maxLength` → `.min()` / `.max()` everywhere
- Required fields in OpenAPI → NOT `.optional()` in Zod

## Debugging
- Stop on test/build failures - do not proceed
- Analyze root cause before fixing, don't randomly patch

## Git Branch Policy
- NEVER push directly to main
- Always create a feature branch and push to that branch
- Use PRs to merge into main

## Finalization
1. Run validation (build, lint, test)
2. Fix any failures automatically
3. Ask for user confirmation
4. Create commit on the feature branch and push to origin
5. Create PR linked to the issue
